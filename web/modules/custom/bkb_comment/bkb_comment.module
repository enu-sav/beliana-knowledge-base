<?php

declare(strict_types=1);

/**
 * @file
 * Provides a comment entity type.
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Render\Element;
use Drupal\user\UserInterface;
use Drupal\views\ViewExecutable;
use Drupal\views\Plugin\views\query\QueryPluginBase;

/**
 * Implements hook_theme().
 */
function bkb_comment_theme(): array {
  return [
    'source_comment' => ['render element' => 'elements'],
    'source_comment_node' => ['render element' => 'elements'],
  ];
}

/**
 * Implements hook_theme_registry_alter
 */
function bkb_comment_theme_registry_alter(&$theme_registry) {
  $path = \Drupal::service('extension.list.module')->getPath('bkb_comment');
  $theme_registry['field__comment']['path'] = $path . '/templates';
}

/**
 * Implements hook_form_alter().
 */
function bkb_comment_form_alter(array &$form, FormStateInterface &$form_state, $form_id) {
  switch ($form_id) {
    case 'source_comment_node_add_form':
    case 'source_comment_node_edit_form':
      $form['comments']['widget']['#title'] = t('comment-node-form-fieldset-label');
      $form['comments']['widget']['add_more']['#value'] = t('comment-node-form-add-more-label');

      foreach ($form['comments']['widget'] as $key => &$item) {
        if (is_numeric($key)) {
          if (empty($item['inline_entity_form']['#default_value'])) {
            $item['#field_title'] = t('comment-entity-label-label');
            $item['#open'] = TRUE;
          }
          else {
            if ($comment = $item['inline_entity_form']['#default_value']) {
              $item['#field_title'] = $comment->get('label')->value;
            }
          }
        }
      }
      break;
  }
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 */
function bkb_comment_inline_entity_form_entity_form_alter(array &$entity_form, FormStateInterface &$form_state) {
  switch ($entity_form['#entity_type']) {
    case 'source_comment':
      $entity_form['sources']['widget']['add_more']['#value'] = t('comment-form-add-more-label');
      break;
  }
}

/**
 * Implements hook_views_query_alter().
 */
function bkb_comment_views_query_alter(ViewExecutable $view, QueryPluginBase $query) {
  if ($view->id() == 'comments_overview' && !empty($view->exposed_raw_input['comment'])) {
    foreach ($query->where as &$condition_group) {
      foreach ($condition_group['conditions'] as &$condition) {
        if ($condition['field'] == 'source_comment_source_comment_node__comments.comment') {
          $condition['field'] .= '__value';
        }
      }
    }
  }
}

/**
 * Prepares variables for comment templates.
 *
 * Default template: source-comment.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - elements: An associative array containing the comment information and any
 *     fields attached to the entity.
 *   - attributes: HTML attributes for the containing element.
 */
function template_preprocess_source_comment(array &$variables): void {
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  foreach (Element::children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }
}

/**
 * Prepares variables for word templates.
 *
 * Default template: source-comment-node.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - elements: An associative array containing the word information and any
 *     fields attached to the entity.
 *   - attributes: HTML attributes for the containing element.
 */
function template_preprocess_source_comment_node(array &$variables): void {
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  foreach (Element::children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }
}

/**
 * Implements hook_user_cancel().
 */
function bkb_comment_user_cancel($edit, UserInterface $account, $method): void {
  switch ($method) {
    case 'user_cancel_reassign':
      // Anonymize entities.
      foreach (['source_comment', 'source_comment_node'] as $entity_type) {
        $storage = \Drupal::entityTypeManager()->getStorage($entity_type);
        $ids = $storage->getQuery()
          ->condition('uid', $account->id())
          ->accessCheck(FALSE)
          ->execute();
        foreach ($storage->loadMultiple($ids) as $entity) {
          $entity->setOwnerId(0)->save();
        }
      }
      break;
  }
}

/**
 * Implements hook_ENTITY_TYPE_predelete() for user entities.
 */
function bkb_comment_user_predelete(UserInterface $account): void {
  // Delete entity that belong to this account.
  foreach (['source_comment', 'source_comment_node'] as $entity_type) {
    $storage = \Drupal::entityTypeManager()->getStorage($entity_type);
    $ids = $storage->getQuery()
      ->condition('uid', $account->id())
      ->accessCheck(FALSE)
      ->execute();
    $storage->delete(
      $storage->loadMultiple($ids)
    );
  }
}

/**
 * Implements hook_jsonapi_entity_filter_access.
 */
function bkb_comment_jsonapi_entity_filter_access($entity_type, $account): array {
  return ([
    JSONAPI_FILTER_AMONG_ALL => AccessResult::allowed(),
  ]);
}
